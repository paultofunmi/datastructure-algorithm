Algorithms

- Big O notation / logarithm (and why it is faster)
- Traversal: Graph, Tree, Matrix (DFS/BFS)
- Binary Search (logarithm time complexity: faster than linear): used for searching sorted values
- Two pointer mechanism
- Recursion
- Inverting a binary tree and reversing LinkedIn List
- Suffix Trees
- Heaps (Binary Heaps, Min and Max Heaps): they have log time complexity
- Dynamic Programming
- Quick Sort and Merge Sort 


Avoid these: 
- Over-communicating: If you need to take time to think through the problem, ask for it (say: give me 20 - 60 secs to think about this). this is better than rambling
- List bunch of DS without explaining why and what they would do.
- Jumping into the coding without giving thought to how you will code the solution.
- Not confirming the inputs to problem statements matches what the interviewer expects

### Web Resources
- https://cheonhyangzhang.gitbooks.io/leetcode-solutions/content/solutions-451-500/490-the-maze.html
- https://github.com/paultofunmi/every-programmer-should-know
- https://github.com/paultofunmi/Facebook-Interview-Coding
- https://github.com/paultofunmi/coding-interview-university
- https://github.com/paultofunmi/system-design-primer
- https://www.youtube.com/watch?v=YgzpqlF54lo&list=PLKQ5LYb497AZIZe9dBWy8GwLluVaMQVj0 (Think Like a programmer playlist)
- https://www.youtube.com/watch?v=pfiQ_PS1g8E&list=PLot-Xpze53lf5C3HSjCnyFghlW0G1HHXo (Backtracking problems)
- https://www.youtube.com/watch?v=Zq4upTEaQyM&list=PLiQ766zSC5jM2OKVr8sooOuGgZkvnOCTI (Dynamic Programming, Recursion, & Backtracking - Back to Back SWE)
- https://www.youtube.com/watch?v=U6-X_QOwPcs&list=PLU_sdQYzUj2keVENTP0a5rdykRSgg9Wp- (Nick White Leetcode solutions)

### Leetcode algorithm tags
- https://leetcode.com/tag/backtracking/
- https://leetcode.com/tag/matrix/
- https://leetcode.com/tag/array/
- https://leetcode.com/tag/dynamic-programming/

### Company Challenges
- https://app.codesignal.com/company-challenges/uber
- https://app.codesignal.com/company-challenges/codesignal

FAANG Candidates are evaluated based on: 
- Coding - How clean & structured is your code?  Could you write the code that you said you would write?  Did you cover the edge and base cases?  Are your variables and functions well-named? 
Data Structures & Algorithms - Could you come up with a suitable algorithm or data structure to solve the problem efficiently?  Could you analyze that solution in terms of time & space complexity and the trade-offs?  Did you demonstrate mastery of the data structures available and create your own data structures as necessary with private/public APIs?  Could you think critically to analyze various alternatives and compare brute force solutions versus more optimal solutions?

- Communication - Were you able to clarify the problem as needed, and then explain the solution?  Many software engineers will try to talk as they are coding, and the words come out as a jumble of stuttered "uhmm.... hold on... ah.... wait.... give me 2 seconds... oh... ,nevermind..."  Some engineers simply talk in a way that is too technical and incomprehensible "... then we increment the variable i by the variable j minus one and check if j is equal to k..."  The ability to communicate effectively is crucial because coding is a team sport at the end of the day.

- Speed & Efficiency - Unlike in the old days, tech companies have been trying to avoid "aha!" moments where candidates either know or don't know the answer.  It is far more favored for interviewers to ask questions that can build atop of itself (such as increasingly adding restrictions or pushing for faster time/space), so that interviewers can get some signal on the candidate's ability beyond just "pass" or "no pass."  This is why fluidity & confidence is essential.  So, even if you may have heard of some of these problems before once or twice, it really helps to become great at these and see how "the pros" solve these problems to help you recognize patterns in code and in crafting elegant & simple solutions.